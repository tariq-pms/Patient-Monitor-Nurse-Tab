{
  "version": 3,
  "sources": ["../../hammerjs/hammer.js", "../../chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],
  "sourcesContent": ["/*! Hammer.JS - v2.0.7 - 2016-04-22\r\n * http://hammerjs.github.io/\r\n *\r\n * Copyright (c) 2016 Jorik Tangelder;\r\n * Licensed under the MIT license */\r\n(function(window, document, exportName, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\r\nvar TEST_ELEMENT = document.createElement('div');\r\n\r\nvar TYPE_FUNCTION = 'function';\r\n\r\nvar round = Math.round;\r\nvar abs = Math.abs;\r\nvar now = Date.now;\r\n\r\n/**\r\n * set a timeout with a given scope\r\n * @param {Function} fn\r\n * @param {Number} timeout\r\n * @param {Object} context\r\n * @returns {number}\r\n */\r\nfunction setTimeoutContext(fn, timeout, context) {\r\n    return setTimeout(bindFn(fn, context), timeout);\r\n}\r\n\r\n/**\r\n * if the argument is an array, we want to execute the fn on each entry\r\n * if it aint an array we don't want to do a thing.\r\n * this is used by all the methods that accept a single and array argument.\r\n * @param {*|Array} arg\r\n * @param {String} fn\r\n * @param {Object} [context]\r\n * @returns {Boolean}\r\n */\r\nfunction invokeArrayArg(arg, fn, context) {\r\n    if (Array.isArray(arg)) {\r\n        each(arg, context[fn], context);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        i = 0;\r\n        while (i < obj.length) {\r\n            iterator.call(context, obj[i], i, obj);\r\n            i++;\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * wrap a method with a deprecation warning and stack trace\r\n * @param {Function} method\r\n * @param {String} name\r\n * @param {String} message\r\n * @returns {Function} A new function wrapping the supplied method.\r\n */\r\nfunction deprecate(method, name, message) {\r\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\r\n    return function() {\r\n        var e = new Error('get-stack-trace');\r\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\r\n            .replace(/^\\s+at\\s+/gm, '')\r\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\r\n\r\n        var log = window.console && (window.console.warn || window.console.log);\r\n        if (log) {\r\n            log.call(window.console, deprecationMessage, stack);\r\n        }\r\n        return method.apply(this, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} target\r\n * @param {...Object} objects_to_assign\r\n * @returns {Object} target\r\n */\r\nvar assign;\r\nif (typeof Object.assign !== 'function') {\r\n    assign = function assign(target) {\r\n        if (target === undefined || target === null) {\r\n            throw new TypeError('Cannot convert undefined or null to object');\r\n        }\r\n\r\n        var output = Object(target);\r\n        for (var index = 1; index < arguments.length; index++) {\r\n            var source = arguments[index];\r\n            if (source !== undefined && source !== null) {\r\n                for (var nextKey in source) {\r\n                    if (source.hasOwnProperty(nextKey)) {\r\n                        output[nextKey] = source[nextKey];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n} else {\r\n    assign = Object.assign;\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge=false]\r\n * @returns {Object} dest\r\n */\r\nvar extend = deprecate(function extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    var i = 0;\r\n    while (i < keys.length) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n        i++;\r\n    }\r\n    return dest;\r\n}, 'extend', 'Use `assign`.');\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nvar merge = deprecate(function merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}, 'merge', 'Use `assign`.');\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    childP = child.prototype = Object.create(baseP);\r\n    childP.constructor = child;\r\n    childP._super = baseP;\r\n\r\n    if (properties) {\r\n        assign(childP, properties);\r\n    }\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function boundFn() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || undefined : undefined, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n    return (val1 === undefined) ? val2 : val1;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(target, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        target.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(target, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        target.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        var i = 0;\r\n        while (i < src.length) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n            i++;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @param {Boolean} [sort=False]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key, sort) {\r\n    var results = [];\r\n    var values = [];\r\n    var i = 0;\r\n\r\n    while (i < src.length) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n        i++;\r\n    }\r\n\r\n    if (sort) {\r\n        if (!key) {\r\n            results = results.sort();\r\n        } else {\r\n            results = results.sort(function sortUniqueArray(a, b) {\r\n                return a[key] > b[key];\r\n            });\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    var i = 0;\r\n    while (i < VENDOR_PREFIXES.length) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n        i++;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\n/**\r\n * get the window object of an element\r\n * @param {HTMLElement} element\r\n * @returns {DocumentView|Window}\r\n */\r\nfunction getWindowForElement(element) {\r\n    var doc = element.ownerDocument || element;\r\n    return (doc.defaultView || doc.parentWindow || window);\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n    this.element = manager.element;\r\n    this.target = manager.options.inputTarget;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(manager.options.enable, [manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.init();\r\n\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\r\n    handler: function() { },\r\n\r\n    /**\r\n     * bind the events\r\n     */\r\n    init: function() {\r\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\r\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\r\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n    },\r\n\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\r\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\r\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * called by the Manager constructor\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    var inputClass = manager.options.inputClass;\r\n\r\n    if (inputClass) {\r\n        Type = inputClass;\r\n    } else if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = !!isFirst;\r\n    input.isFinal = !!isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    // emit secret event\r\n    manager.emit('hammer.input', input);\r\n\r\n    manager.recognize(input);\r\n    manager.session.prevInput = input;\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\r\n    var center = input.center = getCenter(pointers);\r\n    input.timeStamp = now();\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n\r\n    computeDeltaXY(session, input);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\r\n    input.overallVelocityX = overallVelocity.x;\r\n    input.overallVelocityY = overallVelocity.y;\r\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\r\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\r\n\r\n    computeIntervalInputData(session, input);\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n}\r\n\r\nfunction computeDeltaXY(session, input) {\r\n    var center = input.center;\r\n    var offset = session.offsetDelta || {};\r\n    var prevDelta = session.prevDelta || {};\r\n    var prevInput = session.prevInput || {};\r\n\r\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\r\n        prevDelta = session.prevDelta = {\r\n            x: prevInput.deltaX || 0,\r\n            y: prevInput.deltaY || 0\r\n        };\r\n\r\n        offset = session.offsetDelta = {\r\n            x: center.x,\r\n            y: center.y\r\n        };\r\n    }\r\n\r\n    input.deltaX = prevDelta.x + (center.x - offset.x);\r\n    input.deltaY = prevDelta.y + (center.y - offset.y);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval || input,\r\n        deltaTime = input.timeStamp - last.timeStamp,\r\n        velocity, velocityX, velocityY, direction;\r\n\r\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\r\n        var deltaX = input.deltaX - last.deltaX;\r\n        var deltaY = input.deltaY - last.deltaY;\r\n\r\n        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n        velocityX = v.x;\r\n        velocityY = v.y;\r\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\r\n        direction = getDirection(deltaX, deltaY);\r\n\r\n        session.lastInterval = input;\r\n    } else {\r\n        // use latest velocity info if it doesn't overtake a minimum period\r\n        velocity = last.velocity;\r\n        velocityX = last.velocityX;\r\n        velocityY = last.velocityY;\r\n        direction = last.direction;\r\n    }\r\n\r\n    input.velocity = velocity;\r\n    input.velocityX = velocityX;\r\n    input.velocityY = velocityY;\r\n    input.direction = direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    var i = 0;\r\n    while (i < input.pointers.length) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n        i++;\r\n    }\r\n\r\n    return {\r\n        timeStamp: now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0, i = 0;\r\n    while (i < pointersLength) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n        i++;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: x / deltaTime || 0,\r\n        y: y / deltaTime || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (abs(x) >= abs(y)) {\r\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction MouseInput() {\r\n    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function MEhandler(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down\r\n        if (!this.pressed) {\r\n            return;\r\n        }\r\n\r\n        if (eventType & INPUT_END) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\r\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent && !window.PointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction PointerEventInput() {\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function PEhandler(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\r\n\r\n        // get index of the event in the store\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\r\n            if (storeIndex < 0) {\r\n                store.push(ev);\r\n                storeIndex = store.length - 1;\r\n            }\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar SINGLE_TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\r\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction SingleTouchInput() {\r\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\r\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\r\n    this.started = false;\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(SingleTouchInput, Input, {\r\n    handler: function TEhandler(ev) {\r\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\r\n\r\n        // should we handle the touch events?\r\n        if (type === INPUT_START) {\r\n            this.started = true;\r\n        }\r\n\r\n        if (!this.started) {\r\n            return;\r\n        }\r\n\r\n        var touches = normalizeSingleTouches.call(this, ev, type);\r\n\r\n        // when done, reset the started state\r\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\r\n            this.started = false;\r\n        }\r\n\r\n        this.callback(this.manager, type, {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction normalizeSingleTouches(ev, type) {\r\n    var all = toArray(ev.touches);\r\n    var changed = toArray(ev.changedTouches);\r\n\r\n    if (type & (INPUT_END | INPUT_CANCEL)) {\r\n        all = uniqueArray(all.concat(changed), 'identifier', true);\r\n    }\r\n\r\n    return [all, changed];\r\n}\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Multi-user touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchInput() {\r\n    this.evTarget = TOUCH_TARGET_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    handler: function MTEhandler(ev) {\r\n        var type = TOUCH_INPUT_MAP[ev.type];\r\n        var touches = getTouches.call(this, ev, type);\r\n        if (!touches) {\r\n            return;\r\n        }\r\n\r\n        this.callback(this.manager, type, {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction getTouches(ev, type) {\r\n    var allTouches = toArray(ev.touches);\r\n    var targetIds = this.targetIds;\r\n\r\n    // when there is only one touch, the process can be simplified\r\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\r\n        targetIds[allTouches[0].identifier] = true;\r\n        return [allTouches, allTouches];\r\n    }\r\n\r\n    var i,\r\n        targetTouches,\r\n        changedTouches = toArray(ev.changedTouches),\r\n        changedTargetTouches = [],\r\n        target = this.target;\r\n\r\n    // get target touches from touches\r\n    targetTouches = allTouches.filter(function(touch) {\r\n        return hasParent(touch.target, target);\r\n    });\r\n\r\n    // collect touches\r\n    if (type === INPUT_START) {\r\n        i = 0;\r\n        while (i < targetTouches.length) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n            i++;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    i = 0;\r\n    while (i < changedTouches.length) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (type & (INPUT_END | INPUT_CANCEL)) {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n        i++;\r\n    }\r\n\r\n    if (!changedTargetTouches.length) {\r\n        return;\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\n\r\nvar DEDUP_TIMEOUT = 2500;\r\nvar DEDUP_DISTANCE = 25;\r\n\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    var handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, handler);\r\n    this.mouse = new MouseInput(this.manager, handler);\r\n\r\n    this.primaryTouch = null;\r\n    this.lastTouches = [];\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function TMEhandler(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\r\n            return;\r\n        }\r\n\r\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\r\n        if (isTouch) {\r\n            recordTouches.call(this, inputEvent, inputData);\r\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\r\n            return;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function destroy() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nfunction recordTouches(eventType, eventData) {\r\n    if (eventType & INPUT_START) {\r\n        this.primaryTouch = eventData.changedPointers[0].identifier;\r\n        setLastTouch.call(this, eventData);\r\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n        setLastTouch.call(this, eventData);\r\n    }\r\n}\r\n\r\nfunction setLastTouch(eventData) {\r\n    var touch = eventData.changedPointers[0];\r\n\r\n    if (touch.identifier === this.primaryTouch) {\r\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\r\n        this.lastTouches.push(lastTouch);\r\n        var lts = this.lastTouches;\r\n        var removeLastTouch = function() {\r\n            var i = lts.indexOf(lastTouch);\r\n            if (i > -1) {\r\n                lts.splice(i, 1);\r\n            }\r\n        };\r\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\r\n    }\r\n}\r\n\r\nfunction isSyntheticEvent(eventData) {\r\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\r\n    for (var i = 0; i < this.lastTouches.length; i++) {\r\n        var t = this.lastTouches[i];\r\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\r\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\nvar TOUCH_ACTION_MAP = getTouchActionProps();\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase().trim();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var actions = [];\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        return cleanTouchActions(actions.join(' '));\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\r\n\r\n        if (hasNone) {\r\n            //do not prevent defaults if this is a tap gesture\r\n\r\n            var isTapPointer = input.pointers.length === 1;\r\n            var isTapMovement = input.distance < 2;\r\n            var isTapTouchTime = input.deltaTime < 250;\r\n\r\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (hasPanX && hasPanY) {\r\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\r\n            return;\r\n        }\r\n\r\n        if (hasNone ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n\r\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\r\n    // if both pan-x and pan-y are set (different recognizers\r\n    // for different directions, e.g. horizontal pan but vertical swipe?)\r\n    // we need none (as otherwise with pan-x pan-y combined none of these\r\n    // recognizers will work, since the browser would handle all panning\r\n    if (hasPanX && hasPanY) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n\r\n    // pan-x OR pan-y\r\n    if (hasPanX || hasPanY) {\r\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\r\n    }\r\n\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\nfunction getTouchActionProps() {\r\n    if (!NATIVE_TOUCH_ACTION) {\r\n        return false;\r\n    }\r\n    var touchMap = {};\r\n    var cssSupports = window.CSS && window.CSS.supports;\r\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\r\n\r\n        // If css.supports is not supported but there is native touch-action assume it supports\r\n        // all values. This is the case for IE 10 and 11.\r\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\r\n    });\r\n    return touchMap;\r\n}\r\n\r\n/**\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.options = assign({}, this.defaults, options || {});\r\n\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n\r\n    // default is enable true\r\n    this.options.enable = ifUndefined(this.options.enable, true);\r\n\r\n    this.state = STATE_POSSIBLE;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @return {Recognizer}\r\n     */\r\n    set: function(options) {\r\n        assign(this.options, options);\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\r\n            return this;\r\n        }\r\n\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\r\n            return this;\r\n        }\r\n\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\r\n            return this;\r\n        }\r\n\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\r\n            return this;\r\n        }\r\n\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\r\n    hasRequireFailures: function() {\r\n        return this.requireFail.length > 0;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        var self = this;\r\n        var state = this.state;\r\n\r\n        function emit(event) {\r\n            self.manager.emit(event, input);\r\n        }\r\n\r\n        // 'panstart' and 'panmove'\r\n        if (state < STATE_ENDED) {\r\n            emit(self.options.event + stateStr(state));\r\n        }\r\n\r\n        emit(self.options.event); // simple 'eventName' events\r\n\r\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\r\n            emit(input.additionalEvent);\r\n        }\r\n\r\n        // panend and pancancel\r\n        if (state >= STATE_ENDED) {\r\n            emit(self.options.event + stateStr(state));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\r\n    tryEmit: function(input) {\r\n        if (this.canEmit()) {\r\n            return this.emit(input);\r\n        }\r\n        // it's failing anyway\r\n        this.state = STATE_FAILED;\r\n    },\r\n\r\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\r\n    canEmit: function() {\r\n        var i = 0;\r\n        while (i < this.requireFail.length) {\r\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                return false;\r\n            }\r\n            i++;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = assign({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.tryEmit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\r\n    defaults: {\r\n        /**\r\n         * @type {Number}\r\n         * @default 1\r\n         */\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n    },\r\n\r\n    emit: function(input) {\r\n\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        var direction = directionStr(input.direction);\r\n\r\n        if (direction) {\r\n            input.additionalEvent = this.options.event + direction;\r\n        }\r\n        this._super.emit.call(this, input);\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            input.additionalEvent = this.options.event + inOut;\r\n        }\r\n        this._super.emit.call(this, input);\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 251, // minimal time of the pointer to be pressed\r\n        threshold: 9 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            this._timer = setTimeoutContext(function() {\r\n                this.state = STATE_RECOGNIZED;\r\n                this.tryEmit();\r\n            }, options.time, this);\r\n        } else if (input.eventType & INPUT_END) {\r\n            return STATE_RECOGNIZED;\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function(input) {\r\n        if (this.state !== STATE_RECOGNIZED) {\r\n            return;\r\n        }\r\n\r\n        if (input && (input.eventType & INPUT_END)) {\r\n            this.manager.emit(this.options.event + 'up', input);\r\n        } else {\r\n            this._input.timeStamp = now();\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.3,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.overallVelocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.overallVelocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.overallVelocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.offsetDirection &&\r\n            input.distance > this.options.threshold &&\r\n            input.maxPointers == this.options.pointers &&\r\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        var direction = directionStr(input.offsetDirection);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n\r\n        this.manager.emit(this.options.event, input);\r\n    }\r\n});\r\n\r\n/**\r\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        interval: 300, // max time between the multi-tap taps\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 9, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        this.reset();\r\n\r\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n            return this.failTimeout();\r\n        }\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (validMovement && validTouchTime && validPointers) {\r\n            if (input.eventType != INPUT_END) {\r\n                return this.failTimeout();\r\n            }\r\n\r\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n            this.pTime = input.timeStamp;\r\n            this.pCenter = input.center;\r\n\r\n            if (!validMultiTap || !validInterval) {\r\n                this.count = 1;\r\n            } else {\r\n                this.count += 1;\r\n            }\r\n\r\n            this._input = input;\r\n\r\n            // if tap count matches we have recognized it,\r\n            // else it has began recognizing...\r\n            var tapCount = this.count % options.taps;\r\n            if (tapCount === 0) {\r\n                // no failing requirements, immediately trigger the tap event\r\n                // or wait as long as the multitap interval to trigger\r\n                if (!this.hasRequireFailures()) {\r\n                    return STATE_RECOGNIZED;\r\n                } else {\r\n                    this._timer = setTimeoutContext(function() {\r\n                        this.state = STATE_RECOGNIZED;\r\n                        this.tryEmit();\r\n                    }, options.interval, this);\r\n                    return STATE_BEGAN;\r\n                }\r\n            }\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    failTimeout: function() {\r\n        this._timer = setTimeoutContext(function() {\r\n            this.state = STATE_FAILED;\r\n        }, this.options.interval, this);\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Simple way to create a manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\r\n    return new Manager(element, options);\r\n}\r\n\r\n/**\r\n * @const {string}\r\n */\r\nHammer.VERSION = '2.0.7';\r\n\r\n/**\r\n * default settings\r\n * @namespace\r\n */\r\nHammer.defaults = {\r\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    domEvents: false,\r\n\r\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\r\n    enable: true,\r\n\r\n    /**\r\n     * EXPERIMENTAL FEATURE -- can be removed/changed\r\n     * Change the parent input target element.\r\n     * If Null, then it is being set the to main element.\r\n     * @type {Null|EventTarget}\r\n     * @default null\r\n     */\r\n    inputTarget: null,\r\n\r\n    /**\r\n     * force an input class\r\n     * @type {Null|Function}\r\n     * @default null\r\n     */\r\n    inputClass: null,\r\n\r\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\r\n    preset: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, {enable: false}],\r\n        [PinchRecognizer, {enable: false}, ['rotate']],\r\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\r\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\r\n    cssProps: {\r\n        /**\r\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userSelect: 'none',\r\n\r\n        /**\r\n         * Disable the Windows Phone grippers when pressing an element.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchSelect: 'none',\r\n\r\n        /**\r\n         * Disables the default callout shown when you touch and hold a touch target.\r\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n         * a callout containing information about the link. This property allows you to disable that callout.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchCallout: 'none',\r\n\r\n        /**\r\n         * Specifies whether zooming is enabled. Used by IE10>\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        contentZooming: 'none',\r\n\r\n        /**\r\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userDrag: 'none',\r\n\r\n        /**\r\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n         * @type {String}\r\n         * @default 'rgba(0,0,0,0)'\r\n         */\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\nvar STOP = 1;\r\nvar FORCED_STOP = 2;\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    this.options = assign({}, Hammer.defaults, options || {});\r\n\r\n    this.options.inputTarget = this.options.inputTarget || element;\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n    this.oldCssProps = {};\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(this.options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && recognizer.recognizeWith(item[2]);\r\n        item[3] && recognizer.requireFailure(item[3]);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @returns {Manager}\r\n     */\r\n    set: function(options) {\r\n        assign(this.options, options);\r\n\r\n        // Options that need a little more setup\r\n        if (options.touchAction) {\r\n            this.touchAction.update();\r\n        }\r\n        if (options.inputTarget) {\r\n            // Clean up existing event listeners and reinitialize\r\n            this.input.destroy();\r\n            this.input.target = options.inputTarget;\r\n            this.input.init();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? FORCED_STOP : STOP;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        var session = this.session;\r\n        if (session.stopped) {\r\n            return;\r\n        }\r\n\r\n        // run the touch-action polyfill\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var recognizers = this.recognizers;\r\n\r\n        // this holds the recognizer that is being recognized.\r\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n        // if no recognizer is detecting a thing, it is set to `null`\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is recognized\r\n        // or when we're in a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        var i = 0;\r\n        while (i < recognizers.length) {\r\n            recognizer = recognizers[i];\r\n\r\n            // find out if we are allowed try to recognize the input for this one.\r\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n            //      that is being recognized.\r\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n            if (session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n            // current active recognizer. but only if we don't already have an active recognizer\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n            i++;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer|Manager}\r\n     */\r\n    add: function(recognizer) {\r\n        if (invokeArrayArg(recognizer, 'add', this)) {\r\n            return this;\r\n        }\r\n\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Manager}\r\n     */\r\n    remove: function(recognizer) {\r\n        if (invokeArrayArg(recognizer, 'remove', this)) {\r\n            return this;\r\n        }\r\n\r\n        recognizer = this.get(recognizer);\r\n\r\n        // let's make sure this recognizer exists\r\n        if (recognizer) {\r\n            var recognizers = this.recognizers;\r\n            var index = inArray(recognizers, recognizer);\r\n\r\n            if (index !== -1) {\r\n                recognizers.splice(index, 1);\r\n                this.touchAction.update();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        if (events === undefined) {\r\n            return;\r\n        }\r\n        if (handler === undefined) {\r\n            return;\r\n        }\r\n\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        if (events === undefined) {\r\n            return;\r\n        }\r\n\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event] && this.handlers[event].slice();\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        var i = 0;\r\n        while (i < handlers.length) {\r\n            handlers[i](data);\r\n            i++;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        this.element && toggleCssProps(this, false);\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    if (!element.style) {\r\n        return;\r\n    }\r\n    var prop;\r\n    each(manager.options.cssProps, function(value, name) {\r\n        prop = prefixed(element.style, name);\r\n        if (add) {\r\n            manager.oldCssProps[prop] = element.style[prop];\r\n            element.style[prop] = value;\r\n        } else {\r\n            element.style[prop] = manager.oldCssProps[prop] || '';\r\n        }\r\n    });\r\n    if (!add) {\r\n        manager.oldCssProps = {};\r\n    }\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nassign(Hammer, {\r\n    INPUT_START: INPUT_START,\r\n    INPUT_MOVE: INPUT_MOVE,\r\n    INPUT_END: INPUT_END,\r\n    INPUT_CANCEL: INPUT_CANCEL,\r\n\r\n    STATE_POSSIBLE: STATE_POSSIBLE,\r\n    STATE_BEGAN: STATE_BEGAN,\r\n    STATE_CHANGED: STATE_CHANGED,\r\n    STATE_ENDED: STATE_ENDED,\r\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n    STATE_CANCELLED: STATE_CANCELLED,\r\n    STATE_FAILED: STATE_FAILED,\r\n\r\n    DIRECTION_NONE: DIRECTION_NONE,\r\n    DIRECTION_LEFT: DIRECTION_LEFT,\r\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n    DIRECTION_UP: DIRECTION_UP,\r\n    DIRECTION_DOWN: DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n    DIRECTION_ALL: DIRECTION_ALL,\r\n\r\n    Manager: Manager,\r\n    Input: Input,\r\n    TouchAction: TouchAction,\r\n\r\n    TouchInput: TouchInput,\r\n    MouseInput: MouseInput,\r\n    PointerEventInput: PointerEventInput,\r\n    TouchMouseInput: TouchMouseInput,\r\n    SingleTouchInput: SingleTouchInput,\r\n\r\n    Recognizer: Recognizer,\r\n    AttrRecognizer: AttrRecognizer,\r\n    Tap: TapRecognizer,\r\n    Pan: PanRecognizer,\r\n    Swipe: SwipeRecognizer,\r\n    Pinch: PinchRecognizer,\r\n    Rotate: RotateRecognizer,\r\n    Press: PressRecognizer,\r\n\r\n    on: addEventListeners,\r\n    off: removeEventListeners,\r\n    each: each,\r\n    merge: merge,\r\n    extend: extend,\r\n    assign: assign,\r\n    inherit: inherit,\r\n    bindFn: bindFn,\r\n    prefixed: prefixed\r\n});\r\n\r\n// this prevents errors when Hammer is loaded in the presence of an AMD\r\n//  style loader but by script tag, not by the loader.\r\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\r\nfreeGlobal.Hammer = Hammer;\r\n\r\nif (typeof define === 'function' && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window[exportName] = Hammer;\r\n}\r\n\r\n})(window, document, 'Hammer');\r\n", "/*!\r\n* chartjs-plugin-zoom v2.0.1\r\n* undefined\r\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\r\n * Released under the MIT License\r\n */\r\nimport Hammer from 'hammerjs';\r\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\r\n\r\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\r\nconst keyPressed = (key, event) => key && event[key + 'Key'];\r\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\r\n\r\n/**\r\n * @param {string|function} mode can be 'x', 'y' or 'xy'\r\n * @param {string} dir can be 'x' or 'y'\r\n * @param {import('chart.js').Chart} chart instance of the chart in question\r\n * @returns {boolean}\r\n */\r\nfunction directionEnabled(mode, dir, chart) {\r\n  if (mode === undefined) {\r\n    return true;\r\n  } else if (typeof mode === 'string') {\r\n    return mode.indexOf(dir) !== -1;\r\n  } else if (typeof mode === 'function') {\r\n    return mode({chart}).indexOf(dir) !== -1;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction directionsEnabled(mode, chart) {\r\n  if (typeof mode === 'function') {\r\n    mode = mode({chart});\r\n  }\r\n  if (typeof mode === 'string') {\r\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\r\n  }\r\n\r\n  return {x: false, y: false};\r\n}\r\n\r\n/**\r\n * Debounces calling `fn` for `delay` ms\r\n * @param {function} fn - Function to call. No arguments are passed.\r\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\r\n * @returns {function}\r\n */\r\nfunction debounce(fn, delay) {\r\n  let timeout;\r\n  return function() {\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(fn, delay);\r\n    return delay;\r\n  };\r\n}\r\n\r\n/**\r\n * Checks which axis is under the mouse cursor.\r\n * @param {{x: number, y: number}} point - the mouse location\r\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\r\n * @return {import('chart.js').Scale}\r\n */\r\nfunction getScaleUnderPoint({x, y}, chart) {\r\n  const scales = chart.scales;\r\n  const scaleIds = Object.keys(scales);\r\n  for (let i = 0; i < scaleIds.length; i++) {\r\n    const scale = scales[scaleIds[i]];\r\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\r\n      return scale;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\r\n * determine which axes are eligible for scaling.\r\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\r\n * @param options - Zoom or pan options\r\n * @param {{x: number, y: number}} point - the mouse location\r\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\r\n * @return {import('chart.js').Scale[]}\r\n */\r\nfunction getEnabledScalesByPoint(options, point, chart) {\r\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\r\n  const scale = getScaleUnderPoint(point, chart);\r\n\r\n  const enabled = directionsEnabled(mode, chart);\r\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\r\n\r\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\r\n  if (overScaleMode) {\r\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\r\n    for (const axis of ['x', 'y']) {\r\n      if (overScaleEnabled[axis]) {\r\n        scaleEnabled[axis] = enabled[axis];\r\n        enabled[axis] = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (scale && scaleEnabled[scale.axis]) {\r\n    return [scale];\r\n  }\r\n\r\n  const enabledScales = [];\r\n  each(chart.scales, function(scaleItem) {\r\n    if (enabled[scaleItem.axis]) {\r\n      enabledScales.push(scaleItem);\r\n    }\r\n  });\r\n  return enabledScales;\r\n}\r\n\r\nconst chartStates = new WeakMap();\r\n\r\nfunction getState(chart) {\r\n  let state = chartStates.get(chart);\r\n  if (!state) {\r\n    state = {\r\n      originalScaleLimits: {},\r\n      updatedScaleLimits: {},\r\n      handlers: {},\r\n      panDelta: {}\r\n    };\r\n    chartStates.set(chart, state);\r\n  }\r\n  return state;\r\n}\r\n\r\nfunction removeState(chart) {\r\n  chartStates.delete(chart);\r\n}\r\n\r\nfunction zoomDelta(scale, zoom, center) {\r\n  const range = scale.max - scale.min;\r\n  const newRange = range * (zoom - 1);\r\n\r\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\r\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\r\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\r\n  const minPercent = Math.max(0, Math.min(1,\r\n    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0\r\n  ));\r\n\r\n  const maxPercent = 1 - minPercent;\r\n\r\n  return {\r\n    min: newRange * minPercent,\r\n    max: newRange * maxPercent\r\n  };\r\n}\r\n\r\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\r\n  let limit = scaleLimits[prop];\r\n  if (limit === 'original') {\r\n    const original = state.originalScaleLimits[scale.id][prop];\r\n    limit = valueOrDefault(original.options, original.scale);\r\n  }\r\n  return valueOrDefault(limit, fallback);\r\n}\r\n\r\nfunction getRange(scale, pixel0, pixel1) {\r\n  const v0 = scale.getValueForPixel(pixel0);\r\n  const v1 = scale.getValueForPixel(pixel1);\r\n  return {\r\n    min: Math.min(v0, v1),\r\n    max: Math.max(v0, v1)\r\n  };\r\n}\r\n\r\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\r\n  const state = getState(scale.chart);\r\n  const {id, axis, options: scaleOpts} = scale;\r\n\r\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\r\n  const {minRange = 0} = scaleLimits;\r\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\r\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\r\n\r\n  const range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\r\n  const offset = (range - max + min) / 2;\r\n  min -= offset;\r\n  max += offset;\r\n\r\n  if (min < minLimit) {\r\n    min = minLimit;\r\n    max = Math.min(minLimit + range, maxLimit);\r\n  } else if (max > maxLimit) {\r\n    max = maxLimit;\r\n    min = Math.max(maxLimit - range, minLimit);\r\n  }\r\n  scaleOpts.min = min;\r\n  scaleOpts.max = max;\r\n\r\n  state.updatedScaleLimits[scale.id] = {min, max};\r\n\r\n  // return true if the scale range is changed\r\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\r\n}\r\n\r\nfunction zoomNumericalScale(scale, zoom, center, limits) {\r\n  const delta = zoomDelta(scale, zoom, center);\r\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\r\n  return updateRange(scale, newRange, limits, true);\r\n}\r\n\r\nfunction zoomRectNumericalScale(scale, from, to, limits) {\r\n  updateRange(scale, getRange(scale, from, to), limits, true);\r\n}\r\n\r\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\r\n\r\nfunction existCategoryFromMaxZoom(scale) {\r\n  const labels = scale.getLabels();\r\n  const maxIndex = labels.length - 1;\r\n\r\n  if (scale.min > 0) {\r\n    scale.min -= 1;\r\n  }\r\n  if (scale.max < maxIndex) {\r\n    scale.max += 1;\r\n  }\r\n}\r\n\r\nfunction zoomCategoryScale(scale, zoom, center, limits) {\r\n  const delta = zoomDelta(scale, zoom, center);\r\n  if (scale.min === scale.max && zoom < 1) {\r\n    existCategoryFromMaxZoom(scale);\r\n  }\r\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\r\n  return updateRange(scale, newRange, limits, true);\r\n}\r\n\r\nfunction scaleLength(scale) {\r\n  return scale.isHorizontal() ? scale.width : scale.height;\r\n}\r\n\r\nfunction panCategoryScale(scale, delta, limits) {\r\n  const labels = scale.getLabels();\r\n  const lastLabelIndex = labels.length - 1;\r\n  let {min, max} = scale;\r\n  // The visible range. Ticks can be skipped, and thus not reliable.\r\n  const range = Math.max(max - min, 1);\r\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\r\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\r\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\r\n  let applied;\r\n  if (delta < -stepDelta) {\r\n    max = Math.min(max + stepSize, lastLabelIndex);\r\n    min = range === 1 ? max : max - range;\r\n    applied = max === lastLabelIndex;\r\n  } else if (delta > stepDelta) {\r\n    min = Math.max(0, min - stepSize);\r\n    max = range === 1 ? min : min + range;\r\n    applied = min === 0;\r\n  }\r\n\r\n  return updateRange(scale, {min, max}, limits) || applied;\r\n}\r\n\r\nconst OFFSETS = {\r\n  second: 500, // 500 ms\r\n  minute: 30 * 1000, // 30 s\r\n  hour: 30 * 60 * 1000, // 30 m\r\n  day: 12 * 60 * 60 * 1000, // 12 h\r\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\r\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\r\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\r\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\r\n};\r\n\r\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\r\n  const {min: prevStart, max: prevEnd, options} = scale;\r\n  const round = options.time && options.time.round;\r\n  const offset = OFFSETS[round] || 0;\r\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\r\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\r\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\r\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\r\n    // At limit: No change but return true to indicate no need to store the delta.\r\n    // NaN can happen for 0-dimension scales (either because they were configured\r\n    // with min === max or because the chart has 0 plottable area).\r\n    return true;\r\n  }\r\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\r\n}\r\n\r\nfunction panNonLinearScale(scale, delta, limits) {\r\n  return panNumericalScale(scale, delta, limits, true);\r\n}\r\n\r\nconst zoomFunctions = {\r\n  category: zoomCategoryScale,\r\n  default: zoomNumericalScale,\r\n};\r\n\r\nconst zoomRectFunctions = {\r\n  default: zoomRectNumericalScale,\r\n};\r\n\r\nconst panFunctions = {\r\n  category: panCategoryScale,\r\n  default: panNumericalScale,\r\n  logarithmic: panNonLinearScale,\r\n  timeseries: panNonLinearScale,\r\n};\r\n\r\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\r\n  const {id, options: {min, max}} = scale;\r\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\r\n    return true;\r\n  }\r\n  const previous = updatedScaleLimits[id];\r\n  return previous.min !== min || previous.max !== max;\r\n}\r\n\r\nfunction removeMissingScales(limits, scales) {\r\n  each(limits, (opt, key) => {\r\n    if (!scales[key]) {\r\n      delete limits[key];\r\n    }\r\n  });\r\n}\r\n\r\nfunction storeOriginalScaleLimits(chart, state) {\r\n  const {scales} = chart;\r\n  const {originalScaleLimits, updatedScaleLimits} = state;\r\n\r\n  each(scales, function(scale) {\r\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\r\n      originalScaleLimits[scale.id] = {\r\n        min: {scale: scale.min, options: scale.options.min},\r\n        max: {scale: scale.max, options: scale.options.max},\r\n      };\r\n    }\r\n  });\r\n\r\n  removeMissingScales(originalScaleLimits, scales);\r\n  removeMissingScales(updatedScaleLimits, scales);\r\n  return originalScaleLimits;\r\n}\r\n\r\nfunction doZoom(scale, amount, center, limits) {\r\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\r\n  callback(fn, [scale, amount, center, limits]);\r\n}\r\n\r\nfunction doZoomRect(scale, amount, from, to, limits) {\r\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\r\n  callback(fn, [scale, amount, from, to, limits]);\r\n}\r\n\r\nfunction getCenter(chart) {\r\n  const ca = chart.chartArea;\r\n  return {\r\n    x: (ca.left + ca.right) / 2,\r\n    y: (ca.top + ca.bottom) / 2,\r\n  };\r\n}\r\n\r\n/**\r\n * @param chart The chart instance\r\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\r\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\r\n */\r\nfunction zoom(chart, amount, transition = 'none') {\r\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\r\n  const state = getState(chart);\r\n  const {options: {limits, zoom: zoomOptions}} = state;\r\n\r\n  storeOriginalScaleLimits(chart, state);\r\n\r\n  const xEnabled = x !== 1;\r\n  const yEnabled = y !== 1;\r\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\r\n\r\n  each(enabledScales || chart.scales, function(scale) {\r\n    if (scale.isHorizontal() && xEnabled) {\r\n      doZoom(scale, x, focalPoint, limits);\r\n    } else if (!scale.isHorizontal() && yEnabled) {\r\n      doZoom(scale, y, focalPoint, limits);\r\n    }\r\n  });\r\n\r\n  chart.update(transition);\r\n\r\n  callback(zoomOptions.onZoom, [{chart}]);\r\n}\r\n\r\nfunction zoomRect(chart, p0, p1, transition = 'none') {\r\n  const state = getState(chart);\r\n  const {options: {limits, zoom: zoomOptions}} = state;\r\n  const {mode = 'xy'} = zoomOptions;\r\n\r\n  storeOriginalScaleLimits(chart, state);\r\n  const xEnabled = directionEnabled(mode, 'x', chart);\r\n  const yEnabled = directionEnabled(mode, 'y', chart);\r\n\r\n  each(chart.scales, function(scale) {\r\n    if (scale.isHorizontal() && xEnabled) {\r\n      doZoomRect(scale, p0.x, p1.x, limits);\r\n    } else if (!scale.isHorizontal() && yEnabled) {\r\n      doZoomRect(scale, p0.y, p1.y, limits);\r\n    }\r\n  });\r\n\r\n  chart.update(transition);\r\n\r\n  callback(zoomOptions.onZoom, [{chart}]);\r\n}\r\n\r\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\r\n  storeOriginalScaleLimits(chart, getState(chart));\r\n  const scale = chart.scales[scaleId];\r\n  updateRange(scale, range, undefined, true);\r\n  chart.update(transition);\r\n}\r\n\r\nfunction resetZoom(chart, transition = 'default') {\r\n  const state = getState(chart);\r\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\r\n\r\n  each(chart.scales, function(scale) {\r\n    const scaleOptions = scale.options;\r\n    if (originalScaleLimits[scale.id]) {\r\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\r\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\r\n    } else {\r\n      delete scaleOptions.min;\r\n      delete scaleOptions.max;\r\n    }\r\n  });\r\n  chart.update(transition);\r\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\r\n}\r\n\r\nfunction getOriginalRange(state, scaleId) {\r\n  const original = state.originalScaleLimits[scaleId];\r\n  if (!original) {\r\n    return;\r\n  }\r\n  const {min, max} = original;\r\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\r\n}\r\n\r\nfunction getZoomLevel(chart) {\r\n  const state = getState(chart);\r\n  let min = 1;\r\n  let max = 1;\r\n  each(chart.scales, function(scale) {\r\n    const origRange = getOriginalRange(state, scale.id);\r\n    if (origRange) {\r\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\r\n      min = Math.min(min, level);\r\n      max = Math.max(max, level);\r\n    }\r\n  });\r\n  return min < 1 ? min : max;\r\n}\r\n\r\nfunction panScale(scale, delta, limits, state) {\r\n  const {panDelta} = state;\r\n  // Add possible cumulative delta from previous pan attempts where scale did not change\r\n  const storedDelta = panDelta[scale.id] || 0;\r\n  if (sign(storedDelta) === sign(delta)) {\r\n    delta += storedDelta;\r\n  }\r\n  const fn = panFunctions[scale.type] || panFunctions.default;\r\n  if (callback(fn, [scale, delta, limits])) {\r\n    // The scale changed, reset cumulative delta\r\n    panDelta[scale.id] = 0;\r\n  } else {\r\n    // The scale did not change, store cumulative delta\r\n    panDelta[scale.id] = delta;\r\n  }\r\n}\r\n\r\nfunction pan(chart, delta, enabledScales, transition = 'none') {\r\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\r\n  const state = getState(chart);\r\n  const {options: {pan: panOptions, limits}} = state;\r\n  const {onPan} = panOptions || {};\r\n\r\n  storeOriginalScaleLimits(chart, state);\r\n\r\n  const xEnabled = x !== 0;\r\n  const yEnabled = y !== 0;\r\n\r\n  each(enabledScales || chart.scales, function(scale) {\r\n    if (scale.isHorizontal() && xEnabled) {\r\n      panScale(scale, x, limits, state);\r\n    } else if (!scale.isHorizontal() && yEnabled) {\r\n      panScale(scale, y, limits, state);\r\n    }\r\n  });\r\n\r\n  chart.update(transition);\r\n\r\n  callback(onPan, [{chart}]);\r\n}\r\n\r\nfunction getInitialScaleBounds(chart) {\r\n  const state = getState(chart);\r\n  storeOriginalScaleLimits(chart, state);\r\n  const scaleBounds = {};\r\n  for (const scaleId of Object.keys(chart.scales)) {\r\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\r\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\r\n  }\r\n\r\n  return scaleBounds;\r\n}\r\n\r\nfunction isZoomedOrPanned(chart) {\r\n  const scaleBounds = getInitialScaleBounds(chart);\r\n  for (const scaleId of Object.keys(chart.scales)) {\r\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\r\n\r\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\r\n      return true;\r\n    }\r\n\r\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction removeHandler(chart, type) {\r\n  const {handlers} = getState(chart);\r\n  const handler = handlers[type];\r\n  if (handler && handler.target) {\r\n    handler.target.removeEventListener(type, handler);\r\n    delete handlers[type];\r\n  }\r\n}\r\n\r\nfunction addHandler(chart, target, type, handler) {\r\n  const {handlers, options} = getState(chart);\r\n  const oldHandler = handlers[type];\r\n  if (oldHandler && oldHandler.target === target) {\r\n    // already attached\r\n    return;\r\n  }\r\n  removeHandler(chart, type);\r\n  handlers[type] = (event) => handler(chart, event, options);\r\n  handlers[type].target = target;\r\n  target.addEventListener(type, handlers[type]);\r\n}\r\n\r\nfunction mouseMove(chart, event) {\r\n  const state = getState(chart);\r\n  if (state.dragStart) {\r\n    state.dragging = true;\r\n    state.dragEnd = event;\r\n    chart.update('none');\r\n  }\r\n}\r\n\r\nfunction keyDown(chart, event) {\r\n  const state = getState(chart);\r\n  if (!state.dragStart || event.key !== 'Escape') {\r\n    return;\r\n  }\r\n\r\n  removeHandler(chart, 'keydown');\r\n  state.dragging = false;\r\n  state.dragStart = state.dragEnd = null;\r\n  chart.update('none');\r\n}\r\n\r\nfunction zoomStart(chart, event, zoomOptions) {\r\n  const {onZoomStart, onZoomRejected} = zoomOptions;\r\n  if (onZoomStart) {\r\n    const point = getRelativePosition(event, chart);\r\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\r\n      callback(onZoomRejected, [{chart, event}]);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction mouseDown(chart, event) {\r\n  const state = getState(chart);\r\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\r\n  if (\r\n    event.button !== 0 ||\r\n    keyPressed(getModifierKey(panOptions), event) ||\r\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\r\n  ) {\r\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\r\n  }\r\n\r\n  if (zoomStart(chart, event, zoomOptions) === false) {\r\n    return;\r\n  }\r\n  state.dragStart = event;\r\n\r\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\r\n  addHandler(chart, window.document, 'keydown', keyDown);\r\n}\r\n\r\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\r\n  const xEnabled = directionEnabled(mode, 'x', chart);\r\n  const yEnabled = directionEnabled(mode, 'y', chart);\r\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\r\n\r\n  const beginPoint = getRelativePosition(beginPointEvent, chart);\r\n  const endPoint = getRelativePosition(endPointEvent, chart);\r\n\r\n  if (xEnabled) {\r\n    left = Math.min(beginPoint.x, endPoint.x);\r\n    right = Math.max(beginPoint.x, endPoint.x);\r\n  }\r\n\r\n  if (yEnabled) {\r\n    top = Math.min(beginPoint.y, endPoint.y);\r\n    bottom = Math.max(beginPoint.y, endPoint.y);\r\n  }\r\n  const width = right - left;\r\n  const height = bottom - top;\r\n\r\n  return {\r\n    left,\r\n    top,\r\n    right,\r\n    bottom,\r\n    width,\r\n    height,\r\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\r\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\r\n  };\r\n}\r\n\r\nfunction mouseUp(chart, event) {\r\n  const state = getState(chart);\r\n  if (!state.dragStart) {\r\n    return;\r\n  }\r\n\r\n  removeHandler(chart, 'mousemove');\r\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\r\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\r\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\r\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\r\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\r\n\r\n  // Remove drag start and end before chart update to stop drawing selected area\r\n  state.dragStart = state.dragEnd = null;\r\n\r\n  if (distance <= threshold) {\r\n    state.dragging = false;\r\n    chart.update('none');\r\n    return;\r\n  }\r\n\r\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\r\n\r\n  setTimeout(() => (state.dragging = false), 500);\r\n  callback(onZoomComplete, [{chart}]);\r\n}\r\n\r\nfunction wheelPreconditions(chart, event, zoomOptions) {\r\n  // Before preventDefault, check if the modifier key required and pressed\r\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\r\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\r\n    return;\r\n  }\r\n\r\n  if (zoomStart(chart, event, zoomOptions) === false) {\r\n    return;\r\n  }\r\n\r\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\r\n  if (event.cancelable) {\r\n    event.preventDefault();\r\n  }\r\n\r\n  // Firefox always fires the wheel event twice:\r\n  // First without the delta and right after that once with the delta properties.\r\n  if (event.deltaY === undefined) {\r\n    return;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction wheel(chart, event) {\r\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\r\n\r\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\r\n    return;\r\n  }\r\n\r\n  const rect = event.target.getBoundingClientRect();\r\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\r\n  const amount = {\r\n    x: speed,\r\n    y: speed,\r\n    focalPoint: {\r\n      x: event.clientX - rect.left,\r\n      y: event.clientY - rect.top\r\n    }\r\n  };\r\n\r\n  zoom(chart, amount);\r\n\r\n  if (onZoomComplete) {\r\n    onZoomComplete();\r\n  }\r\n}\r\n\r\nfunction addDebouncedHandler(chart, name, handler, delay) {\r\n  if (handler) {\r\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\r\n  }\r\n}\r\n\r\nfunction addListeners(chart, options) {\r\n  const canvas = chart.canvas;\r\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\r\n\r\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\r\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\r\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\r\n  if (wheelOptions.enabled) {\r\n    addHandler(chart, canvas, 'wheel', wheel);\r\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\r\n  } else {\r\n    removeHandler(chart, 'wheel');\r\n  }\r\n  if (dragOptions.enabled) {\r\n    addHandler(chart, canvas, 'mousedown', mouseDown);\r\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\r\n  } else {\r\n    removeHandler(chart, 'mousedown');\r\n    removeHandler(chart, 'mousemove');\r\n    removeHandler(chart, 'mouseup');\r\n    removeHandler(chart, 'keydown');\r\n  }\r\n}\r\n\r\nfunction removeListeners(chart) {\r\n  removeHandler(chart, 'mousedown');\r\n  removeHandler(chart, 'mousemove');\r\n  removeHandler(chart, 'mouseup');\r\n  removeHandler(chart, 'wheel');\r\n  removeHandler(chart, 'click');\r\n  removeHandler(chart, 'keydown');\r\n}\r\n\r\nfunction createEnabler(chart, state) {\r\n  return function(recognizer, event) {\r\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\r\n    if (!panOptions || !panOptions.enabled) {\r\n      return false;\r\n    }\r\n    const srcEvent = event && event.srcEvent;\r\n    if (!srcEvent) { // Sometimes Hammer queries this with a null event.\r\n      return true;\r\n    }\r\n    if (!state.panning && event.pointerType === 'mouse' && (\r\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\r\n    ) {\r\n      callback(panOptions.onPanRejected, [{chart, event}]);\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n}\r\n\r\nfunction pinchAxes(p0, p1) {\r\n  // fingers position difference\r\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\r\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\r\n\r\n  // diagonal fingers will change both (xy) axes\r\n  const p = pinchX / pinchY;\r\n  let x, y;\r\n  if (p > 0.3 && p < 1.7) {\r\n    x = y = true;\r\n  } else if (pinchX > pinchY) {\r\n    x = true;\r\n  } else {\r\n    y = true;\r\n  }\r\n  return {x, y};\r\n}\r\n\r\nfunction handlePinch(chart, state, e) {\r\n  if (state.scale) {\r\n    const {center, pointers} = e;\r\n    // Hammer reports the total scaling. We need the incremental amount\r\n    const zoomPercent = 1 / state.scale * e.scale;\r\n    const rect = e.target.getBoundingClientRect();\r\n    const pinch = pinchAxes(pointers[0], pointers[1]);\r\n    const mode = state.options.zoom.mode;\r\n    const amount = {\r\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\r\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\r\n      focalPoint: {\r\n        x: center.x - rect.left,\r\n        y: center.y - rect.top\r\n      }\r\n    };\r\n\r\n    zoom(chart, amount);\r\n\r\n    // Keep track of overall scale\r\n    state.scale = e.scale;\r\n  }\r\n}\r\n\r\nfunction startPinch(chart, state) {\r\n  if (state.options.zoom.pinch.enabled) {\r\n    state.scale = 1;\r\n  }\r\n}\r\n\r\nfunction endPinch(chart, state, e) {\r\n  if (state.scale) {\r\n    handlePinch(chart, state, e);\r\n    state.scale = null; // reset\r\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\r\n  }\r\n}\r\n\r\nfunction handlePan(chart, state, e) {\r\n  const delta = state.delta;\r\n  if (delta) {\r\n    state.panning = true;\r\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\r\n    state.delta = {x: e.deltaX, y: e.deltaY};\r\n  }\r\n}\r\n\r\nfunction startPan(chart, state, event) {\r\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\r\n  if (!enabled) {\r\n    return;\r\n  }\r\n  const rect = event.target.getBoundingClientRect();\r\n  const point = {\r\n    x: event.center.x - rect.left,\r\n    y: event.center.y - rect.top\r\n  };\r\n\r\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\r\n    return callback(onPanRejected, [{chart, event}]);\r\n  }\r\n\r\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\r\n  state.delta = {x: 0, y: 0};\r\n  clearTimeout(state.panEndTimeout);\r\n  handlePan(chart, state, event);\r\n}\r\n\r\nfunction endPan(chart, state) {\r\n  state.delta = null;\r\n  if (state.panning) {\r\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\r\n    callback(state.options.pan.onPanComplete, [{chart}]);\r\n  }\r\n}\r\n\r\nconst hammers = new WeakMap();\r\nfunction startHammer(chart, options) {\r\n  const state = getState(chart);\r\n  const canvas = chart.canvas;\r\n  const {pan: panOptions, zoom: zoomOptions} = options;\r\n\r\n  const mc = new Hammer.Manager(canvas);\r\n  if (zoomOptions && zoomOptions.pinch.enabled) {\r\n    mc.add(new Hammer.Pinch());\r\n    mc.on('pinchstart', () => startPinch(chart, state));\r\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\r\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\r\n  }\r\n\r\n  if (panOptions && panOptions.enabled) {\r\n    mc.add(new Hammer.Pan({\r\n      threshold: panOptions.threshold,\r\n      enable: createEnabler(chart, state)\r\n    }));\r\n    mc.on('panstart', (e) => startPan(chart, state, e));\r\n    mc.on('panmove', (e) => handlePan(chart, state, e));\r\n    mc.on('panend', () => endPan(chart, state));\r\n  }\r\n\r\n  hammers.set(chart, mc);\r\n}\r\n\r\nfunction stopHammer(chart) {\r\n  const mc = hammers.get(chart);\r\n  if (mc) {\r\n    mc.remove('pinchstart');\r\n    mc.remove('pinch');\r\n    mc.remove('pinchend');\r\n    mc.remove('panstart');\r\n    mc.remove('pan');\r\n    mc.remove('panend');\r\n    mc.destroy();\r\n    hammers.delete(chart);\r\n  }\r\n}\r\n\r\nvar version = \"2.0.1\";\r\n\r\nfunction draw(chart, caller, options) {\r\n  const dragOptions = options.zoom.drag;\r\n  const {dragStart, dragEnd} = getState(chart);\r\n\r\n  if (dragOptions.drawTime !== caller || !dragEnd) {\r\n    return;\r\n  }\r\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\r\n  const ctx = chart.ctx;\r\n\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\r\n  ctx.fillRect(left, top, width, height);\r\n\r\n  if (dragOptions.borderWidth > 0) {\r\n    ctx.lineWidth = dragOptions.borderWidth;\r\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\r\n    ctx.strokeRect(left, top, width, height);\r\n  }\r\n  ctx.restore();\r\n}\r\n\r\nvar plugin = {\r\n  id: 'zoom',\r\n\r\n  version,\r\n\r\n  defaults: {\r\n    pan: {\r\n      enabled: false,\r\n      mode: 'xy',\r\n      threshold: 10,\r\n      modifierKey: null,\r\n    },\r\n    zoom: {\r\n      wheel: {\r\n        enabled: false,\r\n        speed: 0.1,\r\n        modifierKey: null\r\n      },\r\n      drag: {\r\n        enabled: false,\r\n        drawTime: 'beforeDatasetsDraw',\r\n        modifierKey: null\r\n      },\r\n      pinch: {\r\n        enabled: false\r\n      },\r\n      mode: 'xy',\r\n    }\r\n  },\r\n\r\n  start: function(chart, _args, options) {\r\n    const state = getState(chart);\r\n    state.options = options;\r\n\r\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\r\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\r\n    }\r\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\r\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\r\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\r\n    }\r\n\r\n    if (Hammer) {\r\n      startHammer(chart, options);\r\n    }\r\n\r\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\r\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\r\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\r\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\r\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\r\n    chart.getZoomLevel = () => getZoomLevel(chart);\r\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\r\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\r\n  },\r\n\r\n  beforeEvent(chart) {\r\n    const state = getState(chart);\r\n    if (state.panning || state.dragging) {\r\n      // cancel any event handling while panning or dragging\r\n      return false;\r\n    }\r\n  },\r\n\r\n  beforeUpdate: function(chart, args, options) {\r\n    const state = getState(chart);\r\n    state.options = options;\r\n    addListeners(chart, options);\r\n  },\r\n\r\n  beforeDatasetsDraw(chart, _args, options) {\r\n    draw(chart, 'beforeDatasetsDraw', options);\r\n  },\r\n\r\n  afterDatasetsDraw(chart, _args, options) {\r\n    draw(chart, 'afterDatasetsDraw', options);\r\n  },\r\n\r\n  beforeDraw(chart, _args, options) {\r\n    draw(chart, 'beforeDraw', options);\r\n  },\r\n\r\n  afterDraw(chart, _args, options) {\r\n    draw(chart, 'afterDraw', options);\r\n  },\r\n\r\n  stop: function(chart) {\r\n    removeListeners(chart);\r\n\r\n    if (Hammer) {\r\n      stopHammer(chart);\r\n    }\r\n    removeState(chart);\r\n  },\r\n\r\n  panFunctions,\r\n  zoomFunctions,\r\n  zoomRectFunctions,\r\n};\r\n\r\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };\r\n"],
  "mappings": "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",
  "names": ["window", "document", "undefined", "each", "assign", "extend", "merge", "callback", "self", "getCenter", "Hammer", "zoom", "Hammer"]
}
